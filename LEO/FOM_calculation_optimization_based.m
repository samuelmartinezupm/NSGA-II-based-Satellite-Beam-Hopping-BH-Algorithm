function [RC,SC,UC,EC,TTS]=FOM_calculation_optimization_based(B_T,b_slots, P_T,  Ill, B, P, UpC, c_scenario, n_users, theta, frame, frame_dur, freq)
RC=0;
SC=0;
UC=0;
EC=0;
TTS=0;

% CQI Table 1: ACM
SE_t1=[0.1523, 0.2344, 0.3770, 0.6016, 0.8770, 1.1758, 1.4766, 1.9141, 2.4063, 2.7305, 3.3223, 3.9023, 4.5234, 5.1152, 5.5574];
SE_t2=[0.1523, 0.3770, 0.8770, 1.4766, 1.9141, 2.4063, 2.7305, 3.3223, 3.9023, 4.5234, 5.1152, 5.5547, 6.2266, 6.9141, 7.4063];

%% Cell Scenario

% Cosq(theta) approximation:
% syms q
% q=vpasolve(cosd(theta/2)^q==1/sqrt(2));
% q=double(q);
q=1.3;

np=1001;
theta_scanning=linspace(-pi/2,pi/2,np);
% Eo=1;
% Ep=Eo*(cos(theta_scanning)).^q;
% figure 
% plot(rad2deg(theta_scanning),20*log10(Ep)); 
% xlim([-90 90]);
% ylim([-10 0]);
% title('Element radiation pattern')
% xlabel('theta (Â°)')
% ylabel('dB')

%% Traffic Flow:
P_T=10*log10(P_T);
G_t=10*log10(0.65*48360/theta^2);
k=-228.6012; %dBW/(HzK^-1)
T_ant=30; %K
alpha=0.1; %roll-off factor

%c_scenario default reset:
for i=1:length(c_scenario)
     c_scenario(i).aggregated_traffic=[]; 
     c_scenario(i).BW=0;
     c_scenario(i).P=0;
     c_scenario(i).active=0;
     c_scenario(i).colour=0;
            for j=1:length(c_scenario(i).users)
                c_scenario(i).users(j).C_N=[];
                c_scenario(i).users(j).P=[];
                c_scenario(i).users(j).BW=[];
                c_scenario(i).users(j).I=[];
                c_scenario(i).users(j).traffic_pending=0;
                c_scenario(i).users(j).traffic_served=zeros(1,frame);
            end
end

for t=1:frame %1frame=10 subframe by 10subframe (beamswithching is performed each frame, for 10 slots constant illumination constant)
    % Traffic Pending Adjustment based on frame length: from second to second add the total demand/s to the pending:
    if mod(t-1,1/frame_dur)==0
        for i=1:length(c_scenario)
            for j=1:length(c_scenario(i).users)
                c_scenario(i).users(j).traffic_pending=c_scenario(i).users(j).traffic_pending+c_scenario(i).users(j).traffic_demand;
            end
        end
    end

    % Agregated_Traffic
    cell_traffic=zeros(1,length(c_scenario));
    for c_idx=1:length(c_scenario)
        c_scenario(c_idx).aggregatetraffic(); % Compute the aggregated cell traffic through the method.
        cell_traffic(c_idx)=c_scenario(c_idx).aggregated_traffic(t); %Take the property that has been generated by the previous method.
        c_scenario(c_idx).BW(t)=0;
        c_scenario(c_idx).P(t)=0;
        c_scenario(c_idx).active(t)=0;
        c_scenario(c_idx).colour(t)=0;
        for u_idx=1:length(c_scenario(c_idx).users)
            c_scenario(c_idx).users(u_idx).C_N(t)=0;
            c_scenario(c_idx).users(u_idx).P(t)=0;
            c_scenario(c_idx).users(u_idx).BW(t)=0;
            c_scenario(c_idx).users(u_idx).traffic_served(t)=0;
        end
    end
    % % PAINT
%     % Map plot per slot:
%     figure (t+2+10) %MAP FIGURE
%     geoshow('landareas.shp')
%     % Satellite Footprint:
%     hold on
%     pgon = nsidedpoly(1000, 'Center',  [0,0], 'Radius', D_footprint/2);
%     Footprint_Latitude=lat_sp+(pgon.Vertices(:,2))/110.574; % approximated conversion from km diff. in x and y to degrees in lat. and long.
%     Footprint_Longitude=lon_sp+(pgon.Vertices(:,1))./(111.32.*cosd(Footprint_Latitude));
%     plot(polyshape(Footprint_Longitude',Footprint_Latitude'),'FaceColor','yellow','EdgeColor', 'black')

    % Power per cell
    P_cell=UpC*P(:,t);
    B_cell=UpC*B(:,:,t);
    B_cell=(B_T/b_slots)*sum(B_cell,2);
    %Illumination based on input [Ill] matrix:
    illuminated_cells=find(Ill(:,t));
    for beam_idx=1:sum(Ill(:,t))
            c_scenario(illuminated_cells(beam_idx)).active(t)=1;
            % Power and BW distribution at cell level:
            % c_scenario(illuminated_cells(beam_idx)).P(t)=P_T+10*log10(P_cell(illuminated_cells(beam_idx))); % [dBW] not uniform distribution, total power is distributed in each beam for the whole trama based on aggregated traffic demand <- INCORPORAR CRITERIO G/T !!!
            % c_scenario(illuminated_cells(beam_idx)).BW(t)=10*log10(B_cell(illuminated_cells(beam_idx))*10^6); %[dBHz]
            % For each user in the selected cell and time slot, compute:
            for u_idx=1:length(c_scenario(illuminated_cells(beam_idx)).users)
                if (c_scenario(illuminated_cells(beam_idx)).users(u_idx).traffic_pending~=0) % If ==0: no need to serve this user of the cell, the illumination is to serve other demanding users of the cell.
                    % Link Budget:
                    % EIRP_tx=P_tx+G_tx:
                    P_tx=10*log10(P(c_scenario(illuminated_cells(beam_idx)).users(u_idx).id,t));
                    G_tx=G_t-12*(c_scenario(illuminated_cells(beam_idx)).users(u_idx).betta_to_center/theta)^2; % Gain loss approximation when moving away from the cell center.
                    [minScanning,closestScanningIndex]=min(abs(theta_scanning(1:((np-1)/2+1))+deg2rad(c_scenario(illuminated_cells(beam_idx)).betta_to_sat))); % Gain loss due to scanning
                    G_tx=G_tx+20*log10(cos(abs(theta_scanning(closestScanningIndex)))^q);
                    % FSL:
                    Lfsl=20*log10(freq)+20*log10(c_scenario(illuminated_cells(beam_idx)).users(u_idx).distace_to_sat*10^3)-147.55;

% EXTRA LOSSES (not considered for the moment):
                    Extra_losses.At=0;
        
                    % Gain RX:
                    G_rx=c_scenario(illuminated_cells(beam_idx)).users(u_idx).gain; %dB
                    % T_eq RX:
                    T_eq=10*log10(T_ant+c_scenario(illuminated_cells(beam_idx)).users(u_idx).T_noise+280*(1-10^(-Extra_losses.At/10))); %[dBK] -> Contributors: captured by antenna + rx equivalent + attenuation due to extra losses
                    % BW RX:
                    BW_rx=10*log10(sum(B(c_scenario(illuminated_cells(beam_idx)).users(u_idx).id,:,t))*(B_T/b_slots)*10^6); % As with the cell power, the cell BW divided based on the traffic demand of the users in the cell to whom resources will be allocate
                    C_N=(G_tx+P_tx-Lfsl-Extra_losses.At+G_rx)-(k+T_eq+BW_rx);
                    
        
                    % Throughput Calculation (C/N -> bits/s): Adaptative Modulation
                    % and Coding Technology in 5G System.
        
        %             % Table 1: For Block Error Rate of 10^-1 and AWWGN
        %             channel:
        %             if C_N<0
        %                 CQI=0.5633*C_N+4.9040;
        %             elseif C_N>=0 && C_N<7
        %                 CQI=0.5639*C_N+4.7443;
        %             elseif C_N>=7 && C_N<14
        %                 CQI=0.5493*C_N+4.5880;
        %             else
        %                 CQI=0.5319*C_N+4.5624;
        %                 if CQI>15 %not to exceed the dimensions of the CQI array, 15 is the maximum.
        %                     CQI=15;
        %                 end
        %             end
        
                    % Table 2:
                    if C_N<4
                        CQI=0.2789*C_N+2.9142;
                    elseif C_N>=4 && C_N<14
                        CQI=0.5246*C_N+1.8749;
                    else
                        CQI=0.5369*C_N+1.4946;
                        if CQI>15 %not to exceed the dimensions of the CQI array, 15 is the maximum.
                            CQI=15;
                        end
                    end
                    
                    if CQI>1
                        SE=SE_t2(floor(round(CQI*100)/100)); % As it is exactly not an integer result, 2nd decimal rounding happens before the floor, so that floor(round(3.999*100)/100) -> 4 or floor(round(3.995*100)/100) -> 4 but floor(round(3.98*100)/100) ->3
                    else %  For really low values of C_N the link can not be ensured, as the required quality (CQI) for basic MODCODs can no be achieved. Therefore, the SE=0.
                        SE=0;
                    end
                    Rs=(10^(BW_rx/10)/(10^6))/(1+alpha); %Msimbol/s <-Comparte BW con esa cantidad de usuarios!
                    Throughput=Rs*SE; %Msimbol/s*bit/simbol=Mbps
                    % Storing:
                    c_scenario(illuminated_cells(beam_idx)).users(u_idx).traffic_served(t)=Throughput;
                    %
                    c_scenario(illuminated_cells(beam_idx)).users(u_idx).P(t)=P_tx;
                    c_scenario(illuminated_cells(beam_idx)).users(u_idx).BW(t)=BW_rx;
                    c_scenario(illuminated_cells(beam_idx)).users(u_idx).C_N(t)=C_N;
        
                    % 
                    c_scenario(illuminated_cells(beam_idx)).users(u_idx).traffic_pending=c_scenario(illuminated_cells(beam_idx)).users(u_idx).traffic_pending-Throughput*(frame_dur);
                    if c_scenario(illuminated_cells(beam_idx)).users(u_idx).traffic_pending<0
                        EC=EC+(-c_scenario(illuminated_cells(beam_idx)).users(u_idx).traffic_pending);
                        c_scenario(illuminated_cells(beam_idx)).users(u_idx).traffic_pending=0;
                    end
                end
            end


    end 

% % PAINT
%     % Plot the cells (colours) that are going to be illuminated in this FRAME:
%     figure (t+2+10) %MAP FIGURE
%     title(append('Cell Scenario (t=',num2str(t),')'))
%     figure (t+2) %SCHEMATIC FIGURE
%     title(append('Cell Scenario (t=',num2str(t),')'))
% 
%     for i=1:number_cells
%         figure (t+2) %SCHEMATIC FIGURE
%         hold on
%         c_scenario(i).draw(t);
%         figure (t+2+10) %MAP FIGURE
%         hold on
%         c_scenario(i).draw_latlong(lat_sp,lon_sp,t);
%         xlim([-80,20])
%         ylim([0,90])
%     end
%     hold off
end

%% GIF
% 
% filename = convertCharsToStrings(strcat('CellScenario_',num2str(rings),'rings.gif')); % Specify the output file name
% for i=2:12
%     figure (i)
%        frame = getframe(gcf);
%     im = frame2im(frame);
%     [imind,cm] = rgb2ind(im,256);
%     if i == 2;
%          imwrite(imind,cm,filename,'gif', 'Loopcount',inf,'DelayTime',0.8);
%     else
%          imwrite(imind,cm,filename,'gif','WriteMode','append','DelayTime',0.8);
%     end
% end
% 
% % Display Illumination Sequence:
% filename = convertCharsToStrings(strcat('CellScenario_MAP_',num2str(rings),'rings.gif'));; % Specify the output file name
% for i=13:22
%     figure (i)
%     frame = getframe(gcf);
%     im = frame2im(frame);
%     [imind,cm] = rgb2ind(im,256);
%     if i == 13;
%          imwrite(imind,cm,filename,'gif', 'Loopcount',inf,'DelayTime',0.8);
%     else
%          imwrite(imind,cm,filename,'gif','WriteMode','append','DelayTime',0.8);
%     end
% end


%% FOM indicators: RC, SC, UC, EC

%Capacities:
for c_idx=1:length(c_scenario)
    for u_idx=1:length(c_scenario(c_idx).users)
        RC=RC+((frame*frame_dur)*c_scenario(c_idx).users(u_idx).traffic_demand);
        SC=SC+((frame*frame_dur)*c_scenario(c_idx).users(u_idx).traffic_demand-c_scenario(c_idx).users(u_idx).traffic_pending);       
        %[c_scenario(c_idx).users(u_idx).id c_scenario(c_idx).users(u_idx).traffic_pending]
        UC=UC+c_scenario(c_idx).users(u_idx).traffic_pending;
    end
end

% for c_idx=1:length(c_scenario)
%     for u_idx=1:length(c_scenario(c_idx).users)
%         GS(c_scenario(c_idx).users(u_idx).id,:)=c_scenario(c_idx).users(u_idx).traffic_demand.*ones(1,10)-c_scenario(c_idx).users(u_idx).traffic_served./10;
%     end
% end

% As simulation time corresponds to (frame/10)s, capacities are divided
% by that value, to have Mbps and not Mb in 10s:

RC=RC/(frame*frame_dur);
SC=SC/(frame*frame_dur);
UC=UC/(frame*frame_dur);



TTS_cell=zeros(1,length(c_scenario));
for c_idx=1:length(c_scenario)
    act_cont=0;
    for idx=1:frame
        if Ill(c_idx,idx)==1
            TTS_cell(c_idx)=TTS_cell(c_idx)+act_cont;
            act_cont=0;
        elseif c_scenario(c_idx).aggregated_traffic(idx)>0 % A cell will be waiting for illumination only if there is traffic to be served, if not, not fair to account the non serving, no users needing it!
            act_cont=act_cont+1;

        end
    end
    if Ill(c_idx,idx)==0 && c_scenario(c_idx).aggregated_traffic(idx)>0 % Consider last 0s as still more traffic to serve. It's best case indeed as it is not assured that in the next frame: frame_total+1 it is going to be served 
            TTS_cell(c_idx)=(TTS_cell(c_idx)+act_cont)/(sum(Ill(c_idx,:))+1); 
    elseif sum(c_scenario(c_idx).aggregated_traffic)>0 % Avoid NaN: the case where it's not last index being 1 but the one with no aggragated traffic ever.
        TTS_cell(c_idx)=(TTS_cell(c_idx))/(sum(Ill(c_idx,:)));
    end
    % User ponderation
    TTS_cell(c_idx)=TTS_cell(c_idx)*length(c_scenario(c_idx).users);
end

TTS=sum(TTS_cell)/n_users;
TTS=TTS*frame_dur; %TTS in seconds

%%
% P_beams=[];
% for c_idx=1:length(c_scenario)
%     for u_idx=1:length(c_scenario(c_idx).users)
%         for t=1:length(c_scenario(c_idx).active)
%             if c_scenario(c_idx).users(u_idx).P(t)>0
%                 P_beams=[P_beams c_scenario(c_idx).users(u_idx).P(t)];
%             end
%         end
%     end
% end
% hist(P_histogram)
% pause(0.5)
end